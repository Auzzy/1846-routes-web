function updateLocalStoragePlacedTiles() {
    if (typeof(Storage) !== "undefined") {
        localStorage.placedTilesTable = JSON.stringify(placedTilesTable.getData());
    }
}

function loadFromLocalStoragePlacedTiles() {
    if (typeof(Storage) !== "undefined") {
        if (localStorage.placedTilesTable !== undefined) {
            placedTilesTableStored = JSON.parse(localStorage.placedTilesTable);
            placedTilesTable.loadData(placedTilesTableStored);
            // Need to add sources to the initial row, since it doesn't trigger afterCreateRow
            addPlacedTileTableSources(placedTilesTableStored.length - 1);
        }
    }
}

function findNextEmptyRow() {
    for (row = 0; row < placedTilesTable.getData().length; row++) {
        if (placedTilesTable.isEmptyRow(row)) {
            return row;
        }
    }
}

function findRowByCoord(coord) {
    for (row = 0; row < placedTilesTable.getData().length; row++) {
        if (placedTilesTable.getDataAtCell(row, 0) === coord) {
            return row;
        }
    }
    return null;
}

function placeTile(coord, tileId, orientation, source) {
    var newRow = placedTilesTable.getData().every(row =>
        row[0] !== coord || row[1] !== tileId || row[2] !== orientation
    );

    if (!newRow) {
        return;
    }

    var row = findRowByCoord(coord);
    if (row === null) {
        // This coordinate isn't already represented, so get a new row.
        row = findNextEmptyRow();
    }
    var source = source || "api";

    placedTilesTable.setDataAtCell([
        [row, 0, coord],
        [row, 1, tileId],
        [row, 2, orientation]
    ]);
}

function removeTile(coord, source) {
    var row = findRowByCoord(coord);
    if (row === null) {
        return;
    }

    var source = source || "api";

    placedTilesTable.setDataAtCell(row, 0, null, source);
}


function tileCoordsSourceFromCoord(coord) {
    return function (query, process) {
        var tileCoords = placedTilesTable.getData().map(row => row[0]);
        $.get("{{ url_for('legal_tile_coords') }}", {coord: coord, tile_coords: JSON.stringify(tileCoords)})
            .done(function(result) {
                process(result["tile-coords"]);
            });
    }
}

function tileCoordsSource(row) {
    return function(query, process) {
        var source = tileCoordsSourceFromCoord(placedTilesTable.getDataAtCell(row, 0));
        source(query, process);
    }
}

function tileIdSourceFromCoord(coord) {
    return function (query, process) {
        $.get("{{ url_for('legal_tiles') }}", {coord: coord})
            .done(function(result) {
                process(result["legal-tile-ids"]);
            });
    }
}

function tileIdSource(row) {
    return function(query, process) {
        var source = tileIdSourceFromCoord(placedTilesTable.getDataAtCell(row, 0));
        source(query, process);
    }
}

function orientationSourceFromCoord(coord, tileId) {
    return function(query, process) {
        $.get("{{ url_for('legal_orientations') }}", {coord: coord, tileId: tileId})
            .done(function(result) {
                process(result["legal-orientations"]);
            });
    }
}

function orientationSource(row) {
    return function(query, process) {
        var source = orientationSourceFromCoord(placedTilesTable.getDataAtCell(row, 0), placedTilesTable.getDataAtCell(row, 1));
        source(query, process);
    }
}

function addPlacedTileTableSources(row) {
    placedTilesTable.setCellMeta(row, 0, "source", tileCoordsSource(row));
    placedTilesTable.setCellMeta(row, 1, "source", tileIdSource(row));
    placedTilesTable.setCellMeta(row, 2, "source", orientationSource(row));
}

function isEmpty(value) {
    return value === '' || value === null || value === undefined;
}

var TileEditor = createTileEditor("{{ url_for('static', filename='images') }}");
var OrientationEditor = createOrientationEditor("{{ url_for('static', filename='images') }}");

var placedTilesTableData = [new Array({{ placed_tiles_colnames | length }}).fill(null)];
var placedTilesTable = new Handsontable(document.getElementById("placed-tiles-table"), {
    data: placedTilesTableData,
    rowHeaders: false,
    colHeaders: {{ placed_tiles_colnames | tojson | safe }},
    startRows: 1,
    minSpareRows: 1,
    enterMoves: {row: 0, col: 1},
    columns: [
        {
            type: 'dropdown',
            allowInvalid: false,
            source: [],
            // Required to allow pasting when using a dynamic source. I'm unclear as to why...
            editor: 'dropdown'
        },
        {
            type: 'dropdown',
            allowInvalid: false,
            source: [],
            editor: false,
            renderer: customTileDropdownRenderer("{{ url_for('static', filename='images') }}"),
            allowHtml: true
        },
        {
            type: 'dropdown',
            allowInvalid: false,
            source: [],
            editor: false,
            renderer: customOrientationDropdownRenderer("{{ url_for('static', filename='images') }}"),
            allowHtml: true
        }
    ],
    afterChange: (changes, source) => {
        if (changes !== null) {
            var changesByRow = {};
            changes.forEach(function(change) {
                var row = change[0].toString();
                if (!Object.keys(changesByRow).includes(row)) {
                    changesByRow[row] = {};
                }
                changesByRow[row][change[1]] = change[3];
            });


            Object.entries(changesByRow).forEach(([row, rowData]) => {
                if (placedTilesTableData[row] !== undefined) {
                    var changedColumns = Object.keys(rowData);
                    if (changedColumns.includes("0")) {
                        placedTilesTableData[row][1] = changedColumns.includes("1") ? rowData[1] : null;
                        placedTilesTableData[row][2] = changedColumns.includes("2") ? rowData[2] : null;
                        placedTilesTable.setCellMeta(row, 1, "editor", isEmpty(placedTilesTableData[row][0]) ? false : TileEditor);
                        placedTilesTable.setCellMeta(row, 2, "editor", false);
                    }

                    if (changedColumns.includes("1")) {
                        placedTilesTableData[row][2] = changedColumns.includes("2") ? rowData[2] : null;
                        placedTilesTable.setCellMeta(row, 2, "editor", isEmpty(placedTilesTable.getDataAtCell(row, 1)) ? false : OrientationEditor);
                    }

                    placedTilesTable.render();
                }
            });

            updateLocalStoragePlacedTiles();
        }

        $("#calculate-submit").prop("disabled", !readyToSelectRailroad());
    },
    afterCreateRow: (index, amount) => {
        Array.from(new Array(amount).keys(), i => i + index).forEach(function(row) {
            addPlacedTileTableSources(row);
        });
    },
    beforePaste: function(data, pasteAreaArray) {
        var pasteArea = pasteAreaArray[0];

        var colNums = Array.from(new Array(data[0].length).keys(), i => i + pasteArea.startCol);

        // Remove all whitespace
        data.slice().forEach(function(row, index) {
            data.splice(index, 1, row.map(col => col.trim()));
        });

        if (colNums.includes(0)) {
            // Remove duplicate coordinates.
            data.slice().forEach(function(row, index) {
                while (true) {
                    var nextMatch = data.slice(index + 1).findIndex(item => item[0] == row[0]);
                    if (nextMatch == -1) {
                        break;
                    }

                    data.splice(index + 1 + nextMatch, 1);
                }
            });
        }

        data.slice().forEach(function(rowData, dataIndex) {
            var rowNum = dataIndex + pasteArea.startRow;
            var coord = colNums.includes(0) ? rowData[colNums.indexOf(0)] : placedTilesTable.getDataAtCell(rowNum, 0);
            var tileId = colNums.includes(1) ? parseInt(rowData[colNums.indexOf(1)], 10) : placedTilesTable.getDataAtCell(rowNum, 1);
            var orientation = colNums.includes(2) ? parseInt(rowData[colNums.indexOf(2)], 10) : placedTilesTable.getDataAtCell(rowNum, 2);

            if (colNums.includes(0)) {
                var sourceFunc = tileCoordsSourceFromCoord(coord);
                sourceFunc("", function(legalValues) {
                    if (!legalValues.includes(coord)) {
                        placedTilesTable.setDataAtCell(rowNum, 0, null, "edit");
                    }
                });
            }
            if (colNums.includes(1)) {
                data[dataIndex][colNums.indexOf(1)] = tileId;

                var sourceFunc = tileIdSourceFromCoord(coord);
                sourceFunc("", function(legalValues) {
                    if (!legalValues.includes(tileId)) {
                        placedTilesTable.setDataAtCell(rowNum, 1, null, "edit");
                    }
                });
            }
            if (colNums.includes(2)) {
                data[dataIndex][colNums.indexOf(2)] = orientation;

                var sourceFunc = orientationSourceFromCoord(coord, tileId);
                sourceFunc("", function(legalValues) {
                    if (!legalValues.includes(orientation)) {
                        placedTilesTable.setDataAtCell(rowNum, 2, null, "edit");
                    }
                });
            }
        });
    },
    afterLoadData: (initialLoad) => {
        if (!initialLoad) {
            placedTilesTableData = placedTilesTable.getData();
            drawMap();
        }
    }
});

addPlacedTileTableSources(0);

// Wait until the map has finished loading to draw the saved map. This is likely to kick in if a cache-refresh page
// reload is issued.
$("#placed-tiles-board").one("load", loadFromLocalStoragePlacedTiles);

// If the image was cached, it may be loaded by the time the above event is attached, so load the saved map immdeiately.
if ($("#placed-tiles-board").get(0).complete) {
    loadFromLocalStoragePlacedTiles();
}

// Handsontable isn't properly displayed due to being hidden. Rendering once it's visible solves the problem.
$("#placed-tiles-tab").on("shown.bs.tab", function(e) {
    placedTilesTable.render();
});