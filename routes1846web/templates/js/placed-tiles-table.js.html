function findNextEmptyRow() {
    for (row = 0; row < placedTilesTableData.length; row++) {
        if (placedTilesTable.isEmptyRow(row)) {
            return row;
        }
    }
}

function findRowByCoord(coord) {
    for (row = 0; row < placedTilesTableData.length; row++) {
        if (placedTilesTableData[row][0] === coord) {
            return row;
        }
    }
    return null;
}

function placeTile(coord, tileId, orientation, source) {
    var newRow = placedTilesTableData.every(row =>
        row[0] !== coord || row[1] !== tileId || row[2] !== orientation
    );

    if (!newRow) {
        return;
    }

    var row = findNextEmptyRow();
    var source = source || "api";

    placedTilesTable.setDataAtCell([
        [row, 0, coord],
        [row, 1, tileId],
        [row, 2, orientation]
    ]);
}

function removeTile(coord, source) {
    var row = findRowByCoord(coord);
    if (row === null) {
        return;
    }

    var source = source || "api";

    placedTilesTable.setDataAtCell(row, 0, null, source);
}


function tileCoordsSourceFromCoord(coord) {
    return function (query, process) {
        var tileCoords = placedTilesTableData.map(row => row[0]);
        $.get("{{ url_for('legal_tile_coords') }}", {coord: coord, tile_coords: JSON.stringify(tileCoords)})
            .done(function(result) {
                process(result["tile-coords"]);
            });
    }
}

function tileCoordsSource(row) {
    return function(query, process) {
        var source = tileCoordsSourceFromCoord(placedTilesTableData[row][0]);
        source(query, process);
    }
}

function tileIdSourceFromCoord(coord) {
    return function (query, process) {
        $.get("{{ url_for('legal_tiles') }}", {coord: coord})
            .done(function(result) {
                process(result["legal-tile-ids"]);
            });
    }
}

function tileIdSource(row) {
    return function(query, process) {
        var source = tileIdSourceFromCoord(placedTilesTableData[row][0]);
        source(query, process);
    }
}

function orientationSourceFromCoord(coord, tileId) {
    return function(query, process) {
        $.get("{{ url_for('legal_orientations') }}", {coord: coord, tileId: tileId})
            .done(function(result) {
                process(result["legal-orientations"]);
            });
    }
}

function orientationSource(row) {
    return function(query, process) {
        var source = orientationSourceFromCoord(placedTilesTableData[row][0], placedTilesTableData[row][1]);
        source(query, process);
    }
}

function addPlacedTileTableSources(row) {
    placedTilesTable.setCellMeta(row, 0, "source", tileCoordsSource(row));
    placedTilesTable.setCellMeta(row, 1, "source", tileIdSource(row));
    placedTilesTable.setCellMeta(row, 2, "source", orientationSource(row));
}

function isEmpty(value) {
    return value === '' || value === null || value === undefined;
}

var TileEditor = createTileEditor("{{ url_for('static', filename='images') }}");
var OrientationEditor = createOrientationEditor("{{ url_for('static', filename='images') }}");

var placedTilesTableData = [new Array({{ placed_tiles_colnames | length }}).fill(null)];
var placedTilesTable = new Handsontable(document.getElementById("placed-tiles-table"), {
    data: placedTilesTableData,
    rowHeaders: false,
    colHeaders: {{ placed_tiles_colnames | tojson | safe }},
    startRows: 1,
    minSpareRows: 1,
    enterMoves: {row: 0, col: 1},
    columns: [
        {
            type: 'dropdown',
            allowInvalid: false,
            source: [],
            // Required to allow pasting when using a dynamic source. I'm unclear as to why...
            editor: 'dropdown'
        },
        {
            type: 'dropdown',
            allowInvalid: false,
            source: [],
            editor: false,
            renderer: customTileDropdownRenderer("{{ url_for('static', filename='images') }}"),
            allowHtml: true
        },
        {
            type: 'dropdown',
            allowInvalid: false,
            source: [],
            editor: false,
            renderer: customOrientationDropdownRenderer("{{ url_for('static', filename='images') }}"),
            allowHtml: true
        }
    ],
    beforeChange: (changes, source) => {
        if (source !== "map") {
            changes.forEach(([row, col, oldValue, newValue]) => {
                if (col === 0 && isEmpty(newValue)) {
                    removeTileFromMap(placedTilesTableData[row][0]);
                }
            });
        }
    },
    afterChange: (changes, source) => {
        if (changes !== null) {
            var changesByRow = {};
            changes.forEach(function(change) {
                var row = change[0].toString();
                if (!Object.keys(changesByRow).includes(row)) {
                    changesByRow[row] = {};
                }
                changesByRow[row][change[1]] = change[3];
            });

            Object.entries(changesByRow).forEach(([row, rowData]) => {
                if (placedTilesTableData[row].some(cell => isEmpty(cell))) {
                    removeTileFromMap(placedTilesTableData[row][0]);
                } else {
                    placeTileOnMap(placedTilesTableData[row][0], placedTilesTableData[row][1], placedTilesTableData[row][2]);
                }

                var changedColumns = Object.keys(rowData);
                if (changedColumns.includes("0")) {
                    placedTilesTableData[row][1] = changedColumns.includes("1") ? rowData[1] : null;
                    placedTilesTableData[row][2] = changedColumns.includes("2") ? rowData[2] : null;
                    placedTilesTable.setCellMeta(row, 1, "editor", isEmpty(placedTilesTableData[row][0]) ? false : TileEditor);
                    placedTilesTable.setCellMeta(row, 2, "editor", false);
                }

                if (changedColumns.includes("1")) {
                    placedTilesTableData[row][2] = changedColumns.includes("2") ? rowData[2] : null;
                    placedTilesTable.setCellMeta(row, 2, "editor", isEmpty(placedTilesTableData[row][1]) ? false : OrientationEditor);
                }

                placedTilesTable.render();
            });
        }

        $("#calculate-submit").prop("disabled", !readyToSelectRailroad());
    },
    afterCreateRow: (index, amount) => {
        Array.from(new Array(amount).keys(), i => i + index).forEach(function(row) {
            addPlacedTileTableSources(row);
        });
    },
    beforePaste: function(data, pasteAreaArray) {
        var pasteArea = pasteAreaArray[0];

        var colNums = Array.from(new Array(data[0].length).keys(), i => i + pasteArea.startCol);

        // Remove all whitespace
        data.slice().forEach(function(row, index) {
            data.splice(index, 1, row.map(col => col.trim()));
        });

        data.slice().forEach(function(rowData, dataIndex) {
            var rowNum = dataIndex + pasteArea.startRow;
            var coord = colNums.includes(0) ? rowData[colNums.indexOf(0)] : placedTilesTableData[rowNum][0];
            var tileId = colNums.includes(1) ? parseInt(rowData[colNums.indexOf(1)], 10) : placedTilesTableData[rowNum][1];
            var orientation = colNums.includes(2) ? parseInt(rowData[colNums.indexOf(2)], 10) : placedTilesTableData[rowNum][2];

            if (colNums.includes(0)) {
                var sourceFunc = tileCoordsSourceFromCoord(coord);
                sourceFunc("", function(legalValues) {
                    if (!legalValues.includes(coord)) {
                        placedTilesTable.setDataAtCell(rowNum, 0, null, "edit");
                    }
                });
            }
            if (colNums.includes(1)) {
                data[dataIndex][colNums.indexOf(1)] = tileId;

                var sourceFunc = tileIdSourceFromCoord(coord);
                sourceFunc("", function(legalValues) {
                    if (!legalValues.includes(tileId)) {
                        placedTilesTable.setDataAtCell(rowNum, 1, null, "edit");
                    }
                });
            }
            if (colNums.includes(2)) {
                data[dataIndex][colNums.indexOf(2)] = orientation;

                var sourceFunc = orientationSourceFromCoord(coord, tileId);
                sourceFunc("", function(legalValues) {
                    if (!legalValues.includes(orientation)) {
                        placedTilesTable.setDataAtCell(rowNum, 2, null, "edit");
                    }
                });
            }
        });
    }
});

// Needed to add sources to the initial row, since it doesn't trigger afterCreateRow
addPlacedTileTableSources(0);

// Handsontable isn't properly displayed due to being hidden. Rendering once it's visible solves the problem.
$("#placed-tiles-tab").on("shown.bs.tab", function(e) {
    placedTilesTable.render();
});